---
title: "Estimation (Numeric Translation)"
author: "Emily Robinson"
date: "Spring 2022"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 3
    number_sections: true
    theme: lumen
---

```{css, echo=FALSE}
.center {
  display: table;
  margin-right: auto;
  margin-left: auto;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE,
	cache = TRUE,
	fig.align = 'center',
	fig.width = 8,
	fig.height = 4 #,
	# options(knitr.kable.NA = '')#,
	# options(knitr.table.format = "pandoc")
)
library(tidyverse)
library(plotly)
library(digest)
library(rstatix)
library(ggpubr)
library(ggforce)
library(patchwork)

library(RSQLite)
library(DBI)
library(here)
library(readr)

library(lme4)
library(emmeans)
library(tictoc)

library(ggwordcloud)
library(wordcloud)
library(RColorBrewer)
library(wordcloud2)
library(tm) 

library(knitr)
```

# Data

```{r, eval = F}
# user data
db_con <- dbConnect(dbDriver("SQLite"), dbname = here("perception-of-statistical-graphics/databases/00_demographics_db.db"))

users <- dbReadTable(db_con,"users")  %>%
  rowwise() %>%
  mutate(participant_id = digest(paste(prolific_id, study_starttime, sep = "-"), "md5"))

completed_sections_orig <- dbReadTable(db_con,"completed_sections")  %>%
  rowwise() %>%
  mutate(participant_id = digest(paste(prolific_id, study_starttime, sep = "-"), "md5"))

dbDisconnect(db_con)

completed_sections_all <- completed_sections_orig %>%
  pivot_wider(id_cols = c("nick_name", "ip_address", "study_starttime"),
              names_from = "section_complete",
              values_from = time)

demographic_data <- full_join(users, completed_sections_all, by = c("nick_name", "ip_address", "study_starttime"))  %>%
  rename(you_draw_it = `you-draw-it`) %>%
  mutate(lineups = ifelse(is.null(lineups), NA, lineups),
         you_draw_it = ifelse(is.null(you_draw_it), NA, you_draw_it),
         estimation = ifelse(is.null(estimation), NA, estimation)) %>%
  mutate(studies_complete = as.numeric(!is.na(lineups)) + as.numeric(!is.na(you_draw_it)) + as.numeric(!is.na(estimation))) %>%
  arrange(-studies_complete)

all_participants <- demographic_data %>% filter(studies_complete == 3, recruitment != "I am the researcher")

# estimation data
db_con <- dbConnect(dbDriver("SQLite"), dbname = here("perception-of-statistical-graphics/databases/03_estimation_db.db"))

estimation_feedback <- dbReadTable(db_con,"feedback")  %>%
  rowwise() %>%
  mutate(participant_id = digest(paste(prolific_id, study_starttime, sep = "-"), "md5"))

estimation_calcfeedback <- dbReadTable(db_con,"calc_feedback")  %>%
  rowwise() %>%
  mutate(participant_id = digest(paste(prolific_id, study_starttime, sep = "-"), "md5")) %>%
  mutate(calculation = paste(expression, "=", round(evaluated, 2), sep = "")) %>%
  group_by(participant_id, q_id, creature, dataset, scale) %>%
  summarise(calculation = paste(calculation, collapse = '; '))

estimation_questions <- dbReadTable(db_con,"estimation_questions") %>%
  mutate(true_value = ifelse(q_id == "QI3", as.numeric(true_value), true_value))
estimation_scenario_text <- dbReadTable(db_con,"scenario_text_data")
estimation_simulated_data <- dbReadTable(db_con,"simulated_data")
estimation_parameters <- dbReadTable(db_con,"true_parameters")

dbDisconnect(db_con)

# combine estimation and user data
joinCols <- c("participant_id", "nick_name", "ip_address", "study_starttime", "prolific_id")

# feedback data
estimation_model_data <- full_join(all_participants, estimation_feedback, by = joinCols) %>%
  left_join(estimation_questions, by = c("q_id", "creature")) %>%
  mutate(response = ifelse(q_id == "QE2" & creature == "tribble", as.character(as.numeric(response) - 4500), response),
         true_value = ifelse(q_id == "QE2" & creature == "tribble", as.numeric(true_value) - 4500, true_value)) %>%
  mutate(deviation = as.numeric(response) - true_value,
         abs_deviation = abs(deviation)) %>%
  full_join(estimation_calcfeedback, by = c("participant_id", "q_id", "creature", "dataset", "scale")) %>%
  mutate(scratchpad = ifelse((scratchpad == "Put scratch-work here..." | is.na(scratchpad)), "", scratchpad),
         calculation = ifelse(is.na(calculation), "", calculation)) %>%
  group_by(participant_id) %>%
  mutate(NQs = n(), .after = participant_id) %>%
  ungroup() %>%
  filter(NQs == 12) %>%
  select(participant_id, NQs, age, gender, academic_study, computer_mouse, recruitment, order, q_id, creature, dataset, scale, response, true_value, deviation, abs_deviation, calculation, scratchpad, qtext)

factorCols <- c("participant_id", "age", "gender", "academic_study", "computer_mouse", "recruitment", "q_id", "creature", "dataset", "scale")
estimation_model_data[,factorCols] <- lapply(estimation_model_data[,factorCols], factor)

write.csv(estimation_model_data, file = here("analyses/03-estimation/estimation-model-data.csv"), row.names = F, na = "")
```

```{r}
# estimation data
db_con <- dbConnect(dbDriver("SQLite"), dbname = here("perception-of-statistical-graphics/databases/03_estimation_db.db"))
estimation_questions <- dbReadTable(db_con,"estimation_questions") %>%
  mutate(true_value = ifelse(q_id == "QI3", as.numeric(true_value), true_value))
estimation_scenario_text <- dbReadTable(db_con,"scenario_text_data")
estimation_simulated_data <- dbReadTable(db_con,"simulated_data")
estimation_parameters <- dbReadTable(db_con,"true_parameters")
dbDisconnect(db_con)

# read in estimation_model_data
estimation_model_data     <- read.csv(here("analyses/03-estimation/estimation-model-data.csv"))

# plot functions
estimationPlots <- function(q_data){

estimation_plot <- q_data %>%
  ggplot(aes(x = scale, y = response, group = participant_id, color = scale, label = paste(calculation, "\n", scratchpad))) +
  geom_linerange(aes(ymin = true_value, ymax = response), position = position_dodge2(0.95), alpha = 0.8, size = 0.1) +
  geom_point(position = position_dodge2(0.95), alpha = 0.8, size = 0.8, shape = 1) +
  geom_hline(aes(yintercept = true_value), linetype = "dashed") +
  facet_wrap(~q_id, scales = "free") +
  theme_bw() +
  theme(axis.text.x = element_blank()) +
  scale_color_manual(values = c("steelblue", "orange"), guide = guide_legend(override.aes = list(size = 1.5, alpha = 1) ))

return(estimation_plot)  

}

estimationPlots_closest_pt <- function(q_data){
  
  estimation_plot <- q_data %>%
    ggplot(aes(x = scale, y = response, group = participant_id, color = scale, label = paste(calculation, "\n", scratchpad))) +
    geom_linerange(aes(ymin = closest_pt_value, ymax = response), position = position_dodge2(0.95), alpha = 0.8, size = 0.1) +
    geom_point(position = position_dodge2(0.95), alpha = 0.8, size = 0.8, shape = 1) +
    geom_hline(aes(yintercept = closest_pt_value), linetype = "dashed") +
    facet_wrap(~q_id + dataset, scales = "free_x") +
    theme_bw() +
    theme(axis.text.x = element_blank()) +
    scale_color_manual(values = c("steelblue", "orange"), guide = guide_legend(override.aes = list(size = 1.5, alpha = 1) ))
  
  return(estimation_plot)  

}
```

A total of `r unique(estimation_model_data$participant_id) %>% length()` participants each completed all 12 estimation questions for a total of `r (unique(estimation_model_data$participant_id) %>% length())*12` estimations.

```{r}
estimation_model_data %>%
  select(participant_id, q_id, creature, dataset, scale, response, qtext, true_value) %>%
  head() %>%
  knitr::kable(digits = 2)
```

# Check Randomization

```{r}
estimation_model_data %>%
  group_by(participant_id) %>%
  mutate(N = n()) %>%
  group_by(participant_id, N, q_id, scale) %>%
  summarize(count = n()) %>%
  mutate(ID = paste(q_id, scale, sep = "-")) %>%
  pivot_wider(id_cols = c("participant_id", "N"),
              names_from = "ID",
              values_from = count) %>%
  arrange(N) %>%
  knitr::kable()
```


```{r, eval = F}
simulated_linear_plot <- estimation_simulated_data %>%
  ggplot(aes(x = (x-3000), y = y)) +
  geom_point() +
  geom_line(aes(y = y0), size = 0.5, color = "gray30", linetype = "dashed") +
  facet_wrap(~dataset, scales = "free") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_y_continuous(limits = c(100, 55000),
                     breaks = seq(0, 55000, 5000),
                     labels = scales::comma,
                     minor_breaks = c())
# ggsave(simulated_linear_plot, filename = here("analyses/03-estimation/simulated-plots/simulated-linear-plot.png"), width = 12, height = 6)

simulated_log_plot <- estimation_simulated_data %>%
  ggplot(aes(x = (x-3000), y = y)) +
  geom_point() +
  geom_line(aes(y = y0), size = 0.5, color = "gray30", linetype = "dashed") +
  facet_wrap(~dataset, scales = "free") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_y_continuous(trans = "log2",
                     limits = c(100, 55000),
                     breaks = 2^seq(0,10000,1),
                     labels = scales::comma,
                     minor_breaks = c())
# ggsave(simulated_log_plot, filename = here("analyses/03-estimation/simulated-plots/simulated-log-plot.png"), width = 12, height = 6)
```

# Q0: Open Ended

```{r}
estimation_questions %>% filter(q_id == "Q0") %>% knitr::kable()
# estimation_model_data %>% filter(q_id == "Q0") %>% select(participant_id, creature, scale, response) %>% knitr::kable()

createWordcloud <- function(q0_data) {
  
  #Create a vector containing only the text
  text <- q0_data[,"response"]
  # Create a corpus  
  docs <- Corpus(VectorSource(text))
  
  docs <- docs %>%
    tm_map(removeNumbers) %>%
    tm_map(removePunctuation) %>%
    tm_map(stripWhitespace)
  docs <- tm_map(docs, content_transformer(tolower))
  docs <- tm_map(docs, removeWords, stopwords("english"))
  
  dtm <- TermDocumentMatrix(docs) 
  matrix <- as.matrix(dtm) 
  words <- sort(rowSums(matrix),decreasing=TRUE) 
  df <- data.frame(word = names(words),freq=words)
  
  set.seed(1234) # for reproducibility 
  wordcloud_plot <- wordcloud(words = df$word, 
                              freq = df$freq, 
                              min.freq = 1, 
                              max.words=200, 
                              random.order=FALSE, 
                              rot.per=0.35, 
                              colors=brewer.pal(8, "Dark2")
                              )
  
  return(wordcloud_plot)

}
```

## Linear Scale

```{r, out.width = "80%"}
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-linear-plot.png"))
```

```{r}
q0linear_data <- estimation_model_data %>% 
  filter(q_id == "Q0", scale == "linear")
createWordcloud(q0linear_data)
```

## Log Scale

```{r, out.width = "80%"}
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-log-plot.png"))
```

```{r}
q0log_data <- estimation_model_data %>% 
  filter(q_id == "Q0", scale == "log2")
createWordcloud(q0log_data)
```

# QE1: Estimate a population given a year

## Question
```{r}
estimation_questions %>% filter(q_id == "QE1") %>% knitr::kable(digits = 2)
```

## Closest Points

```{r}
estimation_simulated_data %>% 
  filter(x == 3010) %>%
  knitr::kable(digits = 2)
```

## Data

Truncated at 5000.

```{r}
qe1_data <- estimation_model_data %>% 
  filter(q_id == "QE1") %>%
  mutate(response = as.numeric(response),
         closest_pt_value = ifelse(dataset == "dataset1", 445.4833, 466.8964),
         closest_pt_deviation = response - closest_pt_value,
         closest_pt_abs_deviation = abs(closest_pt_deviation),
         .after = abs_deviation) %>%
  filter(response <= 5000)

qe1_data %>%
  select(participant_id, dataset, scale, response, true_value, deviation, abs_deviation, closest_pt_value, closest_pt_deviation, closest_pt_abs_deviation) %>%
  head() %>%
  knitr::kable(digits = 2, caption = "QE1 data set example")
```

## Exploration

```{r, out.width = "80%"}
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-linear-plot-QE1.png"))
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-log-plot-QE1.png"))
```

<div class = 'center'>
```{r}
estimation_plotQE1 <- estimationPlots(qe1_data)
ggplotly(estimation_plotQE1)
```
</div>

## Main Take Aways

### More varability in the estimation made on the linear scale

```{r}
qe1_data %>%
  group_by(dataset, scale) %>%
  get_summary_stats(response, type = "median_iqr") %>%
  knitr::kable(digits = 2)

qe1_common_plotv3 <- qe1_data %>%
  ggplot(aes(x = response, fill = scale)) +
  geom_density(alpha = 0.5, color = NA) +
  geom_vline(aes(xintercept = true_value, linetype = "True")) +
  geom_vline(aes(xintercept = closest_pt_value, linetype = "Closest Point")) +
  facet_grid(~ dataset) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dashed", "dotted")) +
  scale_x_continuous("Estimated Population", limits = c(0, 1000)) +
  scale_y_continuous("Density")
qe1_common_plotv3
```

### Participants Anchored their Estimates

**Sub idea:** Participants are estimated based on the points, not based on the visually fitted trend. This is stronger in QE2.

```{r}
qe1_common_responses <- qe1_data %>%
  group_by(scale, dataset, true_value, closest_pt_value, response) %>%
  summarize(count = n()) %>%
  filter(count > 3) %>%
  arrange(scale, -count)

qe1_common_plotv1 <- qe1_common_responses %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(0.9), alpha = 0.7) +
  geom_point(position = position_dodge(0.9)) +
  geom_hline(aes(yintercept = true_value, linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = closest_pt_value, linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_continuous("Estimated Population")

# qe1_common_plotv1

actual_values_data <- qe1_common_responses %>%
  # filter(scale == "linear", "log") %>%
  select(scale, dataset, true_value, closest_pt_value) %>%
  unique() %>%
  pivot_wider(id_cols = c("scale", "true_value"),
              names_from = "dataset",
              values_from = "closest_pt_value") %>%
  pivot_longer(cols = c("true_value", "dataset2", "dataset1"),
              names_to = "dataset",
              values_to = "response") %>%
  mutate(dataset = ifelse(dataset == "true_value" & scale == "linear", "dataset1",
                          ifelse(dataset == "true_value" & scale == "log2", "dataset2", dataset))) %>%
  mutate(scale = "linear", 
         true_value = NA,
         closest_pt_value = NA,
         count = 0) %>%
  unique() %>%
  # mutate(response = round(response, 2)) %>%
  select(scale, dataset, true_value, closest_pt_value, response, count)

qe1_common_responses <- qe1_common_responses %>%
  rbind(actual_values_data)
response_order <- c(unique(round(qe1_common_responses$response, 2))) %>% sort()

qe1_common_plotv2 <- qe1_common_responses %>%
  mutate(response = round(response, 2)) %>%
  mutate(response = factor(response, levels = response_order)) %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(.5)) +
  geom_point(position = position_dodge(0.5)) +
  geom_hline(aes(yintercept = as.factor(round(true_value,2)), linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = as.factor(round(closest_pt_value,2)), linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_discrete("Estimated Population") +
  scale_x_continuous(expand = c(0,0))
qe1_common_plotv2 
```

## Absolute deviation

### True Value

```{r}
qe1_data %>%
  group_by(scale) %>%
  get_summary_stats(abs_deviation, type = "median_iqr") %>%
  knitr::kable(digits = 2)

qe1_data %>%
  ggplot(aes(x = scale, y = abs_deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_zoom(ylim = c(0,1500)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3"))

# qe1_kwMod <- kruskal.test(abs_deviation ~ scale, data = qe1_data)
# qe1_kwMod
```

### Closest point absolute deviation

```{r}
qe1_data %>%
  group_by(scale) %>%
  get_summary_stats(closest_pt_abs_deviation, type = "median_iqr") %>%
  knitr::kable(digits = 2)

qe1_data %>%
  ggplot(aes(x = scale, y = closest_pt_abs_deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_zoom(ylim = c(0,1500)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3"))

# qe1_kwMod <- kruskal.test(closest_pt_abs_deviation ~ scale, data = qe1_data)
# qe1_kwMod
```

# QE2: Estimate a year given a population

## Question
```{r}
estimation_questions %>% filter(q_id == "QE2") %>% knitr::kable(digits = 2)
```

## Closest Points

```{r}
estimation_simulated_data %>% 
  filter(abs(y - 4000) < 1500) %>%
  mutate(x = x - 3000) %>%
  arrange(dataset, y)  %>% 
  knitr::kable(digits = 2)
```

## Data
```{r}
qe2_data <- estimation_model_data %>% 
  filter(q_id == "QE2") %>%
  mutate(response = as.numeric(response),
         closest_pt_value = ifelse(dataset == "dataset1", 24, 27),
         closest_pt_deviation = response - closest_pt_value,
         closest_pt_abs_deviation = abs(closest_pt_deviation),
         .after = abs_deviation) %>%
  filter(response <= 50, response >= 0) %>%
  mutate(true_value = round(true_value, 2))

qe2_data %>%
  select(participant_id, dataset, scale, response, true_value, deviation, abs_deviation, closest_pt_value, closest_pt_deviation, closest_pt_abs_deviation) %>%
  head() %>%
  knitr::kable(digits = 2, caption = "QE2 data set example")
```

## Exploration

```{r, out.width = "80%"}
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-linear-plot-QE2.png"))
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-log-plot-QE2.png"))
```

<div class = 'center'>
```{r}
estimation_plotQE2 <- estimationPlots_closest_pt(qe2_data)
ggplotly(estimation_plotQE2)
```
</div>

## Main Take Aways

### Accuracy

+ About the same on both scales, maybe a slight tendency to overestimate (maybe due to estimating the "visual trend" estimate on the log scale as indicated by data set 1?).
+ Not sure there is enough evidence to claim participants were more accurate on the linear scale, but would like to do more studies focusing on participants ability to read between the y-axis tick marks on the logarithmic scale. They could also be anchoring to the tick mark of 4096.

```{r}
qe2_data %>%
  group_by(dataset, scale) %>%
  get_summary_stats(response, type = "median_iqr") %>%
  knitr::kable(digits = 2)

qe2_density_plot <- qe2_data %>%
  ggplot(aes(x = response, fill = scale)) +
  geom_density(alpha = 0.5, color = NA) +
  geom_vline(aes(xintercept = true_value, linetype = "True")) +
  geom_vline(aes(xintercept = closest_pt_value, linetype = "Closest Point")) +
  facet_grid(~ dataset) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dashed", "dotted")) +
  scale_x_continuous("Estimated Year", limits = c(0, 50)) +
  scale_y_continuous("Density")
qe2_density_plot

qe2_data %>%
  ggplot(aes(x = scale, y = closest_pt_deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_wrap(~dataset) +
  # facet_zoom(ylim = c(-5,5)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_y_continuous(limits = c(-5,5)) +
  ggtitle("Closest Point Deviation (by dataset)")

qe2_data %>%
  ggplot(aes(x = scale, y = closest_pt_deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_zoom(ylim = c(-5,5)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  ggtitle("Closest Point Deviation")

qe2_data %>%
  ggplot(aes(x = scale, y = closest_pt_abs_deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_zoom(ylim = c(-5,5)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  ggtitle("Closest Point Absolute Deviation")
```

### Participants are basing estimates on the simulated data points and not on a visual trendline

+ but... based on the density plots above, on the log scale, participants might have a tendency to be fitting a visual trend first and then estimating as indicated by the overestimation on the log scale for data set 1.

```{r}
qe2_common_responses <- qe2_data %>%
  mutate(true_value = round(true_value, 2)) %>%
  group_by(scale, true_value, closest_pt_value, dataset, response) %>%
  summarize(count = n()) %>%
  filter(count > 3) %>%
  arrange(response)

qe2_common_plotv1 <- qe2_common_responses %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(0.5), alpha = 0.7) +
  geom_point(position = position_dodge(0.5)) +
  geom_hline(aes(yintercept = true_value, linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = closest_pt_value, linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_continuous("Estimated Population")

# qe2_common_plotv1

actual_values_data <- qe2_common_responses %>%
  # filter(scale == "linear", "log") %>%
  select(scale, dataset, true_value, closest_pt_value) %>%
  unique() %>%
  pivot_wider(id_cols = c("scale", "true_value"),
              names_from = "dataset",
              values_from = "closest_pt_value") %>%
  pivot_longer(cols = c("true_value", "dataset2", "dataset1"),
              names_to = "dataset",
              values_to = "response") %>%
  mutate(dataset = ifelse(dataset == "true_value" & scale == "linear", "dataset1",
                          ifelse(dataset == "true_value" & scale == "log2", "dataset2", dataset))) %>%
  mutate(scale = "linear", 
         true_value = NA,
         closest_pt_value = NA,
         count = NA) %>%
  unique() %>%
  # mutate(response = round(response, 2)) %>%
  select(scale, dataset, true_value, closest_pt_value, response, count)

qe2_common_responses <- qe2_common_responses %>%
  rbind(actual_values_data)
response_order <- c(unique(round(qe2_common_responses$response, 2))) %>% sort()

qe2_common_plotv2 <- qe2_common_responses %>%
  mutate(response = round(response, 2)) %>%
  mutate(response = factor(response, levels = response_order)) %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(.5)) +
  geom_point(position = position_dodge(0.5)) +
  geom_hline(aes(yintercept = as.factor(round(true_value,2)), linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = as.factor(round(closest_pt_value,2)), linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_discrete("Estimated Population") +
  scale_x_continuous(expand = c(0,5))
qe2_common_plotv2
```

# QI1: Estimate an additive increase in population between two years

```{r}
estimation_questions %>% filter(q_id == "QI1") %>% knitr::kable()
```

## Closest Points

```{r}
estimation_simulated_data %>% 
  filter(x %in% c(3020, 3040)) %>%
  arrange(dataset) %>%
  pivot_wider(id_cols = c("dataset"),
              names_from = "x",
              values_from = "y") %>%
  mutate(increase = `3040` - `3020`) %>%
  knitr::kable(digits = 2)
```


## Data

+ Truncate data at 30000.

```{r}
qi1_data <- estimation_model_data %>% 
  filter(q_id == "QI1") %>%
  mutate(response = as.numeric(response)) %>%
  mutate(closest_pt_value = ifelse(dataset == "dataset1", 15517.75, 22897.43),
         closest_pt_deviation = response - closest_pt_value,
         closest_pt_abs_deviation = abs(closest_pt_deviation),
         .after = abs_deviation) %>%
  filter(response < 30000)

qi1_data %>%
  select(participant_id, dataset, scale, response, true_value, deviation, abs_deviation, closest_pt_value, closest_pt_deviation, closest_pt_abs_deviation) %>%
  head() %>%
  knitr::kable(digits = 2, caption = "QI1 data set example")
```

## Exploration

+ Quite a few responses in the 10 - 30 range??

```{r, out.width = "80%"}
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-linear-plot-QI1.png"))
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-log-plot-QI1.png"))
```

<div class = 'center'>
```{r}
estimation_plotQI1 <- estimationPlots_closest_pt(qi1_data)
ggplotly(estimation_plotQI1)
```
</div>

## Main Take Aways

### Accuracy

+ Tendency to underestimate the difference (for closest point) and tendency to overestimate the difference (for true value). 

```{r}
qi1_data %>%
  group_by(dataset, scale) %>%
  get_summary_stats(response, type = "median_iqr") %>%
  knitr::kable(digits = 2)

qi1_density_plot <- qi1_data %>%
  filter(response >= 1000) %>%
  ggplot(aes(x = response, fill = scale)) +
  geom_density(alpha = 0.5, color = NA) +
  geom_vline(aes(xintercept = true_value, linetype = "True")) +
  geom_vline(aes(xintercept = closest_pt_value, linetype = "Closest Point")) +
  facet_grid(~ dataset) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_x_continuous("Estimated Difference in Population") +
  scale_y_continuous("Density")
qi1_density_plot

qi1_data %>%
  group_by(dataset, scale) %>%
  get_summary_stats(closest_pt_deviation, type = "median_iqr") %>%
  knitr::kable(digits = 2)

qi1_data %>%
  filter(response >= 1000) %>%
  ggplot(aes(x = scale, y = closest_pt_deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  geom_hline(aes(yintercept = 0), color = "gray30") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_wrap(~dataset) +
  # facet_zoom(ylim = c(-5,5)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_y_continuous("Estimated Deviation") +
  ggtitle("Closest Point Deviation (by dataset)")

qi1_data %>%
  filter(response >= 1000) %>%
  ggplot(aes(x = scale, y = deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  geom_hline(aes(yintercept = 0), color = "gray30") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_wrap(~dataset) +
  # facet_zoom(ylim = c(-5,5)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_y_continuous("Estimated Deviation") +
  ggtitle("True Deviation (by dataset)")
```

### Anchoring & Reading Points

+ For example, 16384 - 1024 = 15360, but that 15000 is still strong.
+ Data set 2 has higher estimates (aka reading the points).

```{r}
qi1_common_responses <- qi1_data %>%
  mutate(true_value = round(true_value, 2)) %>%
  group_by(scale, true_value, closest_pt_value, dataset, response) %>%
  summarize(count = n()) %>%
  filter(count > 3) %>%
  arrange(response)

qi1_common_plotv1 <- qi1_common_responses %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(0.5), alpha = 0.7) +
  geom_point(position = position_dodge(0.5)) +
  geom_hline(aes(yintercept = true_value, linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = closest_pt_value, linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_continuous("Estimated Population")

# qi1_common_plotv1

actual_values_data <- qi1_common_responses %>%
  # filter(scale == "linear", "log") %>%
  select(scale, dataset, true_value, closest_pt_value) %>%
  unique() %>%
  pivot_wider(id_cols = c("scale", "true_value"),
              names_from = "dataset",
              values_from = "closest_pt_value") %>%
  pivot_longer(cols = c("true_value", "dataset2", "dataset1"),
              names_to = "dataset",
              values_to = "response") %>%
  mutate(dataset = ifelse(dataset == "true_value" & scale == "linear", "dataset1",
                          ifelse(dataset == "true_value" & scale == "log2", "dataset2", dataset))) %>%
  mutate(scale = "linear", 
         true_value = NA,
         closest_pt_value = NA,
         count = NA) %>%
  unique() %>%
  # mutate(response = round(response, 2)) %>%
  select(scale, dataset, true_value, closest_pt_value, response, count)

qi1_common_responses <- qi1_common_responses %>%
  rbind(actual_values_data)
response_order <- c(unique(round(qi1_common_responses$response, 2))) %>% sort()

qi1_common_plotv2 <- qi1_common_responses %>%
  mutate(response = round(response, 2)) %>%
  mutate(response = factor(response, levels = response_order)) %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(.5)) +
  geom_point(position = position_dodge(0.5)) +
  geom_hline(aes(yintercept = as.factor(round(true_value,2)), linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = as.factor(round(closest_pt_value,2)), linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_discrete("Estimated Population") +
  scale_x_continuous(expand = c(0,0.5))
qi1_common_plotv2
```

# QI2: Estimate a multiplicative change in population between two years (i.e. how many times larger)

```{r}
estimation_questions %>% filter(q_id == "QI2") %>% knitr::kable()
```

## Closest Points

```{r}
estimation_simulated_data %>% 
  filter(x %in% c(3020, 3040)) %>%
  arrange(dataset) %>%
  pivot_wider(id_cols = c("dataset"),
              names_from = "x",
              values_from = "y") %>%
  mutate(increase = `3040`/`3020`) %>%
  knitr::kable(digits = 2)
```

## Data

+ Truncated at 30000, due to misunderstanding.

```{r}
qi2_data <- estimation_model_data %>% 
  filter(q_id == "QI2") %>%
  mutate(response = as.numeric(response)) %>%
  mutate(closest_pt_value = ifelse(dataset == "dataset1", 11.15, 18.76),
         closest_pt_deviation = response - closest_pt_value,
         closest_pt_abs_deviation = abs(closest_pt_deviation),
         .after = abs_deviation) %>%
  filter(response < 30000)

qi2_data %>%
  select(participant_id, dataset, scale, response, true_value, deviation, abs_deviation, closest_pt_value, closest_pt_deviation, closest_pt_abs_deviation) %>%
  head() %>%
  knitr::kable(digits = 2, caption = "QI2 data set example")
```


## Exploration

```{r, out.width = "80%"}
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-linear-plot-QI2.png"))
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-log-plot-QI2.png"))
```

<div class = 'center'>
```{r}
estimation_plotQI2 <- estimationPlots_closest_pt(qi2_data)
ggplotly(estimation_plotQI2)
```
</div>

## Main Take Aways

### Basic lack of understanding

+ Describe logic from calculation and scratchpad.
+ 15000 was still a common response.

```{r}
estimation_plotQI2
```

### Accuracy

+ Larger variability on linear scale.

```{r}
qi2_data %>%
  group_by(dataset, scale) %>%
  get_summary_stats(response, type = "median_iqr") %>%
  knitr::kable(digits = 2)

qi2_density_plot <- qi2_data %>%
  filter(response < 20) %>%
  ggplot(aes(x = response, fill = scale)) +
  geom_density(alpha = 0.5, color = NA) +
  geom_vline(aes(xintercept = true_value, linetype = "True")) +
  geom_vline(aes(xintercept = closest_pt_value, linetype = "Closest Point")) +
  facet_grid(~ dataset) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_x_continuous("Estimated Difference in Population") +
  scale_y_continuous("Density")
qi2_density_plot

qi2_data %>%
  filter(response < 20) %>%
  ggplot(aes(x = scale, y = closest_pt_deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  geom_hline(aes(yintercept = 0), color = "gray30") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_wrap(~dataset) +
  # facet_zoom(ylim = c(-5,5)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_y_continuous("Estimated Deviation") +
  ggtitle("Closest Point Deviation (by dataset)")

qi2_data %>%
  filter(response < 20) %>%
  ggplot(aes(x = scale, y = deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  geom_hline(aes(yintercept = 0), color = "gray30") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_wrap(~dataset) +
  # facet_zoom(ylim = c(-5,5)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_y_continuous("Estimated Deviation") +
  ggtitle("True Deviation (by dataset)")
```

### Common points

+ Not as strong of an anchoring sense here.
+ Appears to be reading the points.

```{r}
qi2_common_responses <- qi2_data %>%
  mutate(true_value = round(true_value, 2)) %>%
  group_by(scale, true_value, closest_pt_value, dataset, response) %>%
  summarize(count = n()) %>%
  filter(count > 3) %>%
  arrange(response)

qi2_common_plotv1 <- qi2_common_responses %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(0.5), alpha = 0.7) +
  geom_point(position = position_dodge(0.5)) +
  geom_hline(aes(yintercept = true_value, linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = closest_pt_value, linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_continuous("Estimated Population")

# qi2_common_plotv1

actual_values_data <- qi2_common_responses %>%
  # filter(scale == "linear", "log") %>%
  select(scale, dataset, true_value, closest_pt_value) %>%
  unique() %>%
  pivot_wider(id_cols = c("scale", "true_value"),
              names_from = "dataset",
              values_from = "closest_pt_value") %>%
  pivot_longer(cols = c("true_value", "dataset2", "dataset1"),
              names_to = "dataset",
              values_to = "response") %>%
  mutate(dataset = ifelse(dataset == "true_value" & scale == "linear", "dataset1",
                          ifelse(dataset == "true_value" & scale == "log2", "dataset2", dataset))) %>%
  mutate(scale = "linear", 
         true_value = NA,
         closest_pt_value = NA,
         count = NA) %>%
  unique() %>%
  # mutate(response = round(response, 2)) %>%
  select(scale, dataset, true_value, closest_pt_value, response, count)

qi2_common_responses <- qi2_common_responses %>%
  rbind(actual_values_data)
response_order <- c(unique(round(qi2_common_responses$response, 2))) %>% sort()

qi2_common_plotv2 <- qi2_common_responses %>%
  mutate(response = round(response, 2)) %>%
  mutate(response = factor(response, levels = response_order)) %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(.5)) +
  geom_point(position = position_dodge(0.5)) +
  geom_hline(aes(yintercept = as.factor(round(true_value,2)), linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = as.factor(round(closest_pt_value,2)), linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_discrete("Estimated Population") +
  scale_x_continuous(expand = c(0,0.5))
qi2_common_plotv2
```

# QI3: Estimate the number of years necessary to double the population

```{r}
estimation_questions %>% filter(q_id == "QI3") %>% knitr::kable()
```

## Closest Points

From QE1, the estimated population at 10 is:

```{r}
doubled_data <- estimation_simulated_data %>% 
  filter(x == 3010) %>%
  mutate(doubled = y*2)

doubled_data %>%
  knitr::kable(digits = 2)
```

```{r}
estimation_simulated_data %>% 
  left_join(doubled_data %>% select(-c(x, y0, y)), by = c("dataset")) %>%
  mutate(pop_diff = abs(y - doubled),
         year_diff = x - 3010) %>%
  filter(pop_diff < 200) %>%
  arrange(dataset, pop_diff) %>%
  knitr::kable(digits = 2)
```

## Data
```{r}
qi3_data <- estimation_model_data %>% 
  filter(q_id == "QI3") %>%
  mutate(response = as.numeric(response)) %>%
  mutate(closest_pt_value = ifelse(dataset == "dataset1", 4, 6),
         closest_pt_deviation = response - closest_pt_value,
         closest_pt_abs_deviation = abs(closest_pt_deviation),
         .after = abs_deviation) %>%
  filter(response < 50)

qi3_data %>%
  select(participant_id, dataset, scale, response, true_value, deviation, abs_deviation, closest_pt_value, closest_pt_deviation, closest_pt_abs_deviation) %>%
  head() %>%
  knitr::kable(digits = 2, caption = "QI3 data set example")
```

## Exploration

```{r, out.width = "80%"}
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-linear-plot-QI3.png"))
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-log-plot-QI3.png"))
```

<div class = 'center'>
```{r}
estimation_plotQI3 <- estimationPlots_closest_pt(qi3_data)
ggplotly(estimation_plotQI3)
```
</div>


## Main Take Aways

### Accuracy

+ Larger variability on linear scale.
+ More accurate on log scale??

```{r}
qi3_data %>%
  group_by(dataset, scale) %>%
  get_summary_stats(response, type = "median_iqr") %>%
  knitr::kable(digits = 2)

qi3_density_plot <- qi3_data %>%
  ggplot(aes(x = response, fill = scale)) +
  geom_density(alpha = 0.5, color = NA) +
  geom_vline(aes(xintercept = true_value, linetype = "True")) +
  geom_vline(aes(xintercept = closest_pt_value, linetype = "Closest Point")) +
  facet_grid(~ dataset) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_x_continuous("Estimated Difference in Population") +
  scale_y_continuous("Density")
qi3_density_plot

qi3_data %>%
  ggplot(aes(x = scale, y = closest_pt_deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  geom_hline(aes(yintercept = 0), color = "gray30") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_wrap(~dataset) +
  # facet_zoom(ylim = c(-5,5)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_y_continuous("Estimated Deviation") +
  ggtitle("Closest Point Deviation (by dataset)")
```

### Common points

+ Strong anchoring at 5 and 10.

```{r}
qi3_common_responses <- qi3_data %>%
  mutate(true_value = round(true_value, 2)) %>%
  group_by(scale, true_value, closest_pt_value, dataset, response) %>%
  summarize(count = n()) %>%
  filter(count > 3) %>%
  arrange(response)

qi3_common_plotv1 <- qi3_common_responses %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(0.5), alpha = 0.7) +
  geom_point(position = position_dodge(0.5)) +
  geom_hline(aes(yintercept = true_value, linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = closest_pt_value, linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_continuous("Estimated Population")

# qi3_common_plotv1

actual_values_data <- qi3_common_responses %>%
  # filter(scale == "linear", "log") %>%
  select(scale, dataset, true_value, closest_pt_value) %>%
  unique() %>%
  pivot_wider(id_cols = c("scale", "true_value"),
              names_from = "dataset",
              values_from = "closest_pt_value") %>%
  pivot_longer(cols = c("true_value", "dataset2", "dataset1"),
              names_to = "dataset",
              values_to = "response") %>%
  mutate(dataset = ifelse(dataset == "true_value" & scale == "linear", "dataset1",
                          ifelse(dataset == "true_value" & scale == "log2", "dataset2", dataset))) %>%
  mutate(scale = "linear", 
         true_value = NA,
         closest_pt_value = NA,
         count = NA) %>%
  unique() %>%
  # mutate(response = round(response, 2)) %>%
  select(scale, dataset, true_value, closest_pt_value, response, count)

qi3_common_responses <- qi3_common_responses %>%
  rbind(actual_values_data)
response_order <- c(unique(round(qi3_common_responses$response, 2))) %>% sort()

qi3_common_plotv2 <- qi3_common_responses %>%
  mutate(response = round(response, 2)) %>%
  mutate(response = factor(response, levels = response_order)) %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(.5)) +
  geom_point(position = position_dodge(0.5)) +
  geom_hline(aes(yintercept = as.factor(round(true_value,2)), linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = as.factor(round(closest_pt_value,2)), linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_discrete("Estimated Population") +
  scale_x_continuous(expand = c(0,0.5))
qi3_common_plotv2
```
