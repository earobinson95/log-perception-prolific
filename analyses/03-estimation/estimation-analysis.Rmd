---
title: "Estimation (Numeric Translation)"
author: "Emily Robinson"
date: "Spring 2022"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 3
    number_sections: true
    theme: lumen
---

<!-- https://github.com/thomasp85/ggforce/issues/253 -->


```{css, echo=FALSE}
.center {
  display: table;
  margin-right: auto;
  margin-left: auto;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE,
	cache = TRUE,
	fig.align = 'center',
	fig.width = 8,
	fig.height = 4 ,
	dev = "ragg_png"
	# options(knitr.kable.NA = '')#,
	# options(knitr.table.format = "pandoc")
)

library(tidyverse)
library(plotly)
library(digest)
library(rstatix)
library(ggpubr)
library(ggforce)
library(patchwork)

library(RSQLite)
library(DBI)
library(here)
library(readr)
library(readxl)

library(lme4)
library(emmeans)
library(tictoc)

library(ggwordcloud)
library(wordcloud)
library(RColorBrewer)
library(wordcloud2)
library(tm) 
`%notin%` <- Negate(`%in%`)
library(knitr)
```

```{r, eval = F}
# user data
db_con <- dbConnect(dbDriver("SQLite"), dbname = here("perception-of-statistical-graphics/databases/00_demographics_db.db"))

users <- dbReadTable(db_con,"users")  %>%
  rowwise() %>%
  mutate(participant_id = digest(paste(prolific_id, study_starttime, sep = "-"), "md5"))

completed_sections_orig <- dbReadTable(db_con,"completed_sections")  %>%
  rowwise() %>%
  mutate(participant_id = digest(paste(prolific_id, study_starttime, sep = "-"), "md5"))

dbDisconnect(db_con)

completed_sections_all <- completed_sections_orig %>%
  pivot_wider(id_cols = c("nick_name", "ip_address", "study_starttime"),
              names_from = "section_complete",
              values_from = time)

demographic_data <- full_join(users, completed_sections_all, by = c("nick_name", "ip_address", "study_starttime"))  %>%
  rename(you_draw_it = `you-draw-it`) %>%
  mutate(lineups = ifelse(is.null(lineups), NA, lineups),
         you_draw_it = ifelse(is.null(you_draw_it), NA, you_draw_it),
         estimation = ifelse(is.null(estimation), NA, estimation)) %>%
  mutate(studies_complete = as.numeric(!is.na(lineups)) + as.numeric(!is.na(you_draw_it)) + as.numeric(!is.na(estimation))) %>%
  arrange(-studies_complete)

all_participants <- demographic_data %>% filter(studies_complete == 3, recruitment != "I am the researcher")

# estimation data
db_con <- dbConnect(dbDriver("SQLite"), dbname = here("perception-of-statistical-graphics/databases/03_estimation_db.db"))

estimation_feedback <- dbReadTable(db_con,"feedback")  %>%
  rowwise() %>%
  mutate(participant_id = digest(paste(prolific_id, study_starttime, sep = "-"), "md5"))

estimation_calcfeedback <- dbReadTable(db_con,"calc_feedback")  %>%
  rowwise() %>%
  mutate(participant_id = digest(paste(prolific_id, study_starttime, sep = "-"), "md5")) %>%
  mutate(calculation = paste(expression, "=", round(evaluated, 2), sep = "")) %>%
  group_by(participant_id, q_id, creature, dataset, scale) %>%
  summarise(calculation = paste(calculation, collapse = '; '))

estimation_questions <- dbReadTable(db_con,"estimation_questions") %>%
  mutate(true_value = ifelse(q_id == "QI3", as.numeric(true_value), true_value))
estimation_scenario_text <- dbReadTable(db_con,"scenario_text_data")
estimation_simulated_data <- dbReadTable(db_con,"simulated_data")
estimation_parameters <- dbReadTable(db_con,"true_parameters")

dbDisconnect(db_con)

# combine estimation and user data
joinCols <- c("participant_id", "nick_name", "ip_address", "study_starttime", "prolific_id")

# feedback data
estimation_model_data <- full_join(all_participants, estimation_feedback, by = joinCols) %>%
  left_join(estimation_questions, by = c("q_id", "creature")) %>%
  mutate(response = ifelse(q_id == "QE2" & creature == "tribble", as.character(as.numeric(response) - 4500), response),
         true_value = ifelse(q_id == "QE2" & creature == "tribble", as.numeric(true_value) - 4500, true_value)) %>%
  mutate(deviation = as.numeric(response) - true_value,
         abs_deviation = abs(deviation)) %>%
  full_join(estimation_calcfeedback, by = c("participant_id", "q_id", "creature", "dataset", "scale")) %>%
  mutate(scratchpad = ifelse((scratchpad == "Put scratch-work here..." | is.na(scratchpad)), "", scratchpad),
         calculation = ifelse(is.na(calculation), "", calculation)) %>%
  group_by(participant_id) %>%
  mutate(NQs = n(), .after = participant_id) %>%
  ungroup() %>%
  filter(NQs == 12) %>%
  select(participant_id, NQs, age, gender, academic_study, computer_mouse, recruitment, order, q_id, creature, dataset, scale, response, true_value, deviation, abs_deviation, calculation, scratchpad, qtext)

factorCols <- c("participant_id", "age", "gender", "academic_study", "computer_mouse", "recruitment", "q_id", "creature", "dataset", "scale")
estimation_model_data[,factorCols] <- lapply(estimation_model_data[,factorCols], factor)

write.csv(estimation_model_data, file = here("analyses/03-estimation/data/estimation-model-data-orig.csv"), row.names = F, na = "")
```

```{r eval = F}
# read in estimation_model_data
estimation_model_data     <- read_excel(here("analyses/03-estimation/data/estimation-model-data-calc-coding.xlsx"))

# closest point

closest_pt_data <- tibble(q_id = c("QE1", "QE1", "QE2", "QE2", "QI1", "QI1", "QI2", "QI2", "QI3", "QI3"),
                          dataset = rep(c("dataset1", "dataset2"), 5),
                          closest_pt_value = c(445.4833, 466.8964,
                                               24, 27,
                                               15517.75, 22897.43,
                                               11.15, 18.76,
                                               4, 6)
  
)

estimation_model_data2 <- full_join(estimation_model_data, closest_pt_data, by = c("q_id", "dataset")) %>%
  rename(anchored = achnored) %>% 
  mutate(closest_pt_deviation = as.numeric(response) - closest_pt_value,
           closest_pt_abs_deviation = abs(closest_pt_deviation))  %>%
  mutate(showed_work = as.numeric(showed_work)) %>%
  group_by(participant_id) %>%
  mutate(showed_work_n = sum(showed_work, na.rm = T)) %>%
  ungroup() %>%
  select(participant_id, NQs, age, gender, academic_study, computer_mouse, recruitment, order, q_id, qtext, creature, dataset, scale, response, true_value, deviation, abs_deviation, closest_pt_value, closest_pt_deviation, closest_pt_abs_deviation, showed_work, showed_work_n, calculation, scratchpad, pop20_est, pop40_est, anchored, logic, work_notes)

write.csv(estimation_model_data2, file = here("analyses/03-estimation/data/estimation-model-data.csv"), row.names = F, na = "")
```

# Data

```{r}
# estimation data
db_con <- dbConnect(dbDriver("SQLite"), dbname = here("perception-of-statistical-graphics/databases/03_estimation_db.db"))
estimation_questions <- dbReadTable(db_con,"estimation_questions") %>%
  mutate(true_value = ifelse(q_id == "QI3", as.numeric(true_value), true_value))
estimation_scenario_text <- dbReadTable(db_con,"scenario_text_data")
estimation_simulated_data <- dbReadTable(db_con,"simulated_data")
estimation_parameters <- dbReadTable(db_con,"true_parameters")
dbDisconnect(db_con)

# read in estimation_model_data
estimation_model_data <- read.csv(here("analyses/03-estimation/data/estimation-model-data.csv"))

# grid lines
grid_lines_data <- tibble(scale = c(rep("linear", 12), rep("log2", 10)), 
                          grid_lines = c(seq(0,55000, 5000),
                                         2^seq(7,16))
) %>%
  expand_grid(dataset = c("dataset1", "dataset2"))

# plot functions
estimationPlots <- function(q_data){

estimation_plot <- q_data %>%
  ggplot(aes(x = scale, y = response, group = participant_id, color = scale, label = paste(calculation, "\n", scratchpad))) +
  geom_linerange(aes(ymin = true_value, ymax = response), position = position_dodge2(0.95), alpha = 0.8, size = 0.1) +
  geom_point(position = position_dodge2(0.95), alpha = 0.8, size = 0.8, shape = 1) +
  geom_hline(aes(yintercept = true_value), linetype = "dashed") +
  facet_wrap(~q_id, scales = "free") +
  theme_bw() +
  theme(axis.text.x = element_blank()) +
  scale_color_manual(values = c("steelblue", "orange"), guide = guide_legend(override.aes = list(size = 1.5, alpha = 1) ))

return(estimation_plot)  

}

estimationPlots_closest_pt <- function(q_data){
  
  estimation_plot <- q_data %>%
    ggplot(aes(x = scale, y = response, group = participant_id, color = scale, label = paste(calculation, "\n", scratchpad))) +
    geom_linerange(aes(ymin = closest_pt_value, ymax = response), position = position_dodge2(0.95), alpha = 0.8, size = 0.1) +
    geom_point(position = position_dodge2(0.95), alpha = 0.8, size = 0.8, shape = 1) +
    geom_hline(aes(yintercept = closest_pt_value), linetype = "dashed") +
    facet_wrap(~q_id + dataset, scales = "free_x") +
    theme_bw() +
    theme(axis.text.x = element_blank()) +
    scale_color_manual(values = c("steelblue", "orange"), guide = guide_legend(override.aes = list(size = 1.5, alpha = 1) ))
  
  return(estimation_plot)  

}
```

A total of `r unique(estimation_model_data$participant_id) %>% length()` participants each completed all 12 estimation questions for a total of `r (unique(estimation_model_data$participant_id) %>% length())*12` estimations.

```{r}
estimation_model_data %>%
  select(participant_id, q_id, creature, dataset, scale, response, qtext, true_value,closest_pt_value) %>%
  head() %>%
  knitr::kable(digits = 2)
```

<!-- # Check Randomization -->

```{r, eval = F}
estimation_model_data %>%
  group_by(participant_id) %>%
  mutate(N = n()) %>%
  group_by(participant_id, N, q_id, scale) %>%
  summarize(count = n()) %>%
  mutate(ID = paste(q_id, scale, sep = "-")) %>%
  pivot_wider(id_cols = c("participant_id", "N"),
              names_from = "ID",
              values_from = count) %>%
  arrange(N) %>%
  knitr::kable()
```


```{r, eval = F}
simulated_linear_plot <- estimation_simulated_data %>%
  ggplot(aes(x = (x-3000), y = y)) +
  geom_point() +
  geom_line(aes(y = y0), size = 0.5, color = "gray30", linetype = "dashed") +
  facet_wrap(~dataset, scales = "free") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_y_continuous(limits = c(100, 55000),
                     breaks = seq(0, 55000, 5000),
                     labels = scales::comma,
                     minor_breaks = c())
# ggsave(simulated_linear_plot, filename = here("analyses/03-estimation/simulated-plots/simulated-linear-plot.png"), width = 12, height = 6)

simulated_log_plot <- estimation_simulated_data %>%
  ggplot(aes(x = (x-3000), y = y)) +
  geom_point() +
  geom_line(aes(y = y0), size = 0.5, color = "gray30", linetype = "dashed") +
  facet_wrap(~dataset, scales = "free") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_y_continuous(trans = "log2",
                     limits = c(100, 55000),
                     breaks = 2^seq(0,10000,1),
                     labels = scales::comma,
                     minor_breaks = c())
# ggsave(simulated_log_plot, filename = here("analyses/03-estimation/simulated-plots/simulated-log-plot.png"), width = 12, height = 6)
```

# Q0: Open Ended

```{r}
estimation_questions %>% filter(q_id == "Q0") %>% knitr::kable()
# estimation_model_data %>% filter(q_id == "Q0") %>% select(participant_id, creature, scale, response) %>% knitr::kable()

createWordcloud <- function(q0_data) {
  
  #Create a vector containing only the text
  text <- q0_data[,"response"]
  # Create a corpus  
  docs <- Corpus(VectorSource(text))
  
  docs <- docs %>%
    tm_map(removeNumbers) %>%
    tm_map(removePunctuation) %>%
    tm_map(stripWhitespace)
  docs <- tm_map(docs, content_transformer(tolower))
  docs <- tm_map(docs, removeWords, stopwords("english"))
  
  dtm <- TermDocumentMatrix(docs) 
  matrix <- as.matrix(dtm) 
  words <- sort(rowSums(matrix),decreasing=TRUE) 
  df <- data.frame(word = names(words),freq=words)
  
  set.seed(1234) # for reproducibility 
  wordcloud_plot <- wordcloud(words = df$word, 
                              freq = df$freq, 
                              min.freq = 1, 
                              max.words=200, 
                              random.order=FALSE, 
                              rot.per=0.35, 
                              colors=brewer.pal(8, "Dark2")
                              )
  
  return(wordcloud_plot)

}
```

## Linear Scale

```{r, out.width = "80%"}
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-linear-plot.png"))
```

```{r}
q0linear_data <- estimation_model_data %>% 
  filter(q_id == "Q0", scale == "linear")
createWordcloud(q0linear_data)
```

## Log Scale

```{r, out.width = "80%"}
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-log-plot.png"))
```

```{r}
q0log_data <- estimation_model_data %>% 
  filter(q_id == "Q0", scale == "log2")
createWordcloud(q0log_data)
```

# QE1: Estimate a population given a year

## Question
```{r}
estimation_questions %>% filter(q_id == "QE1") %>% knitr::kable(digits = 2)
```

## Closest Points

```{r}
estimation_simulated_data %>% 
  filter(x == 3010) %>%
  knitr::kable(digits = 2)
```

## Data

<!-- Truncated at 5000. -->

```{r}
qe1_data <- estimation_model_data %>% 
  filter(q_id == "QE1") %>%
  mutate(response = as.numeric(response)) %>%
  mutate(showed_work_cutoff = ifelse(showed_work_n >= 2, "yes", "no"))

qe1_data %>%
  select(participant_id, dataset, scale, response, true_value, deviation, abs_deviation, closest_pt_value, closest_pt_deviation, closest_pt_abs_deviation) %>%
  head() %>%
  knitr::kable(digits = 2, caption = "QE1 data set example")
```

## Exploration

```{r, out.width = "80%"}
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-linear-plot-QE1.png"))
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-log-plot-QE1.png"))
```

<div class = 'center'>
```{r}
estimation_plotQE1 <- estimationPlots(qe1_data)
ggplotly(estimation_plotQE1)
```
</div>

## Main Take Aways

### More varability in the estimation made on the linear scale

```{r}
qe1_data %>%
  group_by(dataset, scale) %>%
  get_summary_stats(response, type = "median_iqr") %>%
  knitr::kable(digits = 2)

qe1_common_plotv3 <- qe1_data %>%
  ggplot(aes(x = response, fill = scale)) +
  geom_density(alpha = 0.5, color = NA) +
  geom_vline(aes(xintercept = true_value, linetype = "True")) +
  geom_vline(aes(xintercept = closest_pt_value, linetype = "Closest Point")) +
  facet_grid(~ dataset) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dashed", "dotted")) +
  # coord_cartesian(xlim = c(0,1000), ylim = c(0, 0.1)) +
  scale_x_continuous("Estimated Population", limits = c(0,1000)) +
  scale_y_continuous("Density")
qe1_common_plotv3
```

### Participants Anchored their Estimates

**Sub idea:** Participants are estimated based on the points, not based on the visually fitted trend. This is stronger in QE2.

```{r}
qe1_common_responses <- qe1_data %>%
  group_by(scale, dataset, true_value, closest_pt_value, response) %>%
  summarize(count = n()) %>%
  filter(count > 3) %>%
  arrange(scale, -count)

qe1_common_plotv1 <- qe1_common_responses %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(0.9), alpha = 0.7) +
  geom_point(position = position_dodge(0.9)) +
  geom_hline(aes(yintercept = true_value, linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = closest_pt_value, linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_continuous("Estimated Population")

# qe1_common_plotv1

actual_values_data <- qe1_common_responses %>%
  # filter(scale == "linear", "log") %>%
  select(scale, dataset, true_value, closest_pt_value) %>%
  unique() %>%
  pivot_wider(id_cols = c("scale", "true_value"),
              names_from = "dataset",
              values_from = "closest_pt_value") %>%
  pivot_longer(cols = c("true_value", "dataset2", "dataset1"),
              names_to = "dataset",
              values_to = "response") %>%
  mutate(dataset = ifelse(dataset == "true_value" & scale == "linear", "dataset1",
                          ifelse(dataset == "true_value" & scale == "log2", "dataset2", dataset))) %>%
  mutate(scale = "linear", 
         true_value = NA,
         closest_pt_value = NA,
         count = 0) %>%
  unique() %>%
  # mutate(response = round(response, 2)) %>%
  select(scale, dataset, true_value, closest_pt_value, response, count)

qe1_common_responses <- qe1_common_responses %>%
  rbind(actual_values_data)
response_order <- c(unique(round(qe1_common_responses$response, 2))) %>% sort()

qe1_common_plotv2 <- qe1_common_responses %>%
  mutate(response = round(response, 2)) %>%
  mutate(response = factor(response, levels = response_order)) %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(.5)) +
  geom_point(position = position_dodge(0.5)) +
  geom_hline(aes(yintercept = as.factor(round(true_value,2)), linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = as.factor(round(closest_pt_value,2)), linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_discrete("Estimated Population") +
  scale_x_continuous(expand = c(0,0))
qe1_common_plotv2 
```

## Absolute deviation

### True Value

```{r}
qe1_data %>%
  group_by(scale) %>%
  get_summary_stats(abs_deviation, type = "median_iqr") %>%
  knitr::kable(digits = 2)

qe1_data %>%
  ggplot(aes(x = scale, y = abs_deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_zoom(ylim = c(0,1500)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3"))

# qe1_kwMod <- kruskal.test(abs_deviation ~ scale, data = qe1_data)
# qe1_kwMod
```

### Closest point absolute deviation

```{r}
qe1_data %>%
  group_by(scale) %>%
  get_summary_stats(closest_pt_abs_deviation, type = "median_iqr") %>%
  knitr::kable(digits = 2)

qe1_data %>%
  ggplot(aes(x = scale, y = closest_pt_abs_deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_zoom(ylim = c(0,1500)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3"))

# qe1_kwMod <- kruskal.test(closest_pt_abs_deviation ~ scale, data = qe1_data)
# qe1_kwMod
```

# Years 10, 20, 40 (First level estimates from calculation and scratchpad)

## Compare used scratchpad vs not used scratchpad accuracy for pop10_est

```{r}
qe1_data %>%
  filter(scale == "linear") %>%
  group_by(showed_work_cutoff) %>%
  summarize(count = n()) %>%
  knitr::kable()
```

```{r}
qe1_data %>%
  group_by(dataset, scale, showed_work_cutoff) %>%
  get_summary_stats(response, type = "median_iqr") %>%
  knitr::kable(digits = 2)

qe1_compare_work <- qe1_data %>%
  ggplot(aes(x = response, fill = showed_work_cutoff)) +
  geom_density(alpha = 0.5, color = NA) +
  geom_vline(aes(xintercept = true_value, linetype = "True")) +
  geom_vline(aes(xintercept = closest_pt_value, linetype = "Closest Point")) +
  facet_grid(dataset ~ scale, scales = "free_y") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dashed", "dotted")) +
  # coord_cartesian(xlim = c(0,1000), ylim = c(0, 0.1)) +
  scale_x_continuous("Estimated Population", limits = c(0,1000)) +
  scale_y_continuous("Density")
qe1_compare_work
```

## Data Setup

```{r closest_points}
qe1_pop_est_closest_pts <- estimation_simulated_data %>% 
  filter(x %in% c(3010, 3020, 3040)) %>%
  mutate(year = x - 3000) %>%
  rename(closest_pt_value = y,
         true_value = y0) %>%
  select(dataset, year, true_value, closest_pt_value)
qe1_pop_est_closest_pts %>% knitr::kable()
```

```{r data-setup}

qe1_pop20_est <- estimation_model_data %>%
  filter(!is.na(pop20_est)) %>%
  rename(population_est = pop20_est) %>%
  mutate(year = 20, .after = scale) %>%
  select(participant_id, NQs, age, gender, academic_study, computer_mouse, recruitment, order, q_id, qtext, creature, dataset, scale, year, population_est, showed_work, showed_work_n, calculation, scratchpad)

qe1_pop40_est <- estimation_model_data %>%
  filter(!is.na(pop40_est)) %>%
  rename(population_est = pop40_est) %>%
  mutate(year = 40, .after = scale) %>%
  select(participant_id, NQs, age, gender, academic_study, computer_mouse, recruitment, order, q_id, qtext, creature, dataset, scale, year, population_est, showed_work, showed_work_n, calculation, scratchpad)

qe1_pop10_est <- qe1_data %>%
  rename(population_est = response) %>%
  mutate(year = 10, .after = scale) %>%
  select(participant_id, NQs, age, gender, academic_study, computer_mouse, recruitment, order, q_id, qtext, creature, dataset, scale, year, population_est, showed_work, showed_work_n, calculation, scratchpad)

qe1_pop_est <- rbind(qe1_pop10_est, qe1_pop20_est, qe1_pop40_est) %>%
  arrange(participant_id) %>%
  group_by(participant_id) %>%
  mutate(n_ests = n(), .after = population_est) %>%
  ungroup() %>%
  filter(showed_work_n >= 2) %>%
  full_join(qe1_pop_est_closest_pts, by = c("dataset", "year")) %>%
  mutate(deviation = population_est - true_value,
         abs_deviation = abs(deviation),
         closest_pt_deviation = population_est - closest_pt_value,
         closest_pt_abs_deviation = abs(closest_pt_deviation)) %>%
  mutate(yearest_true = log((population_est - estimation_parameters$theta)/estimation_parameters$alpha)/estimation_parameters$beta + estimation_parameters$xmin - 3000) %>%
  mutate(yearest_true = ifelse(population_est >= 180, yearest_true, NA))

dot_data <- estimation_simulated_data %>%
  mutate(x = x - 3000)
```

```{r, common-responses-data-setup}
qe1_popest_common_responses <- qe1_pop_est %>%
  group_by(scale, year, dataset, true_value, closest_pt_value, population_est) %>%
  summarize(count = n()) %>%
  filter(count > 3) %>%
  arrange(year, scale, -count)

actual_values_data <- qe1_popest_common_responses %>%
  # filter(scale == "linear", "log") %>%
  select(year, scale, dataset, true_value, closest_pt_value) %>%
  unique() %>%
  pivot_wider(id_cols = c("year", "scale", "true_value"),
              names_from = "dataset",
              values_from = "closest_pt_value") %>%
  pivot_longer(cols = c("true_value", "dataset2", "dataset1"),
              names_to = "dataset",
              values_to = "population_est") %>%
  mutate(dataset = ifelse(dataset == "true_value" & scale == "linear", "dataset1",
                          ifelse(dataset == "true_value" & scale == "log2", "dataset2", dataset))) %>%
  mutate(scale = "linear", 
         true_value = NA,
         closest_pt_value = NA,
         count = NA) %>%
  unique() %>%
  select(year, scale, dataset, true_value, closest_pt_value, population_est, count)

qe1_popest_common_responses  <- qe1_popest_common_responses  %>%
  rbind(actual_values_data)
response_order <- c(unique(round(qe1_popest_common_responses$population_est,2))) %>% sort()
```

```{r, spaghettiPlotsSep}

spaghettiPlotsSep <- function(yearVal, datasetID){
  
linear_plot <- qe1_pop_est %>%
  filter(population_est < 55000, year == yearVal, scale == "linear", dataset == datasetID) %>%
ggplot() +
  
  # add points
  geom_point(data = dot_data %>% filter(dataset == datasetID), aes(x = x, y = y)) +
  
  # add spaghetti segments
  geom_segment(aes(x = yearest_true, y = population_est, xend = 0, yend = population_est, color = scale), alpha = 0.3) +
  geom_segment(aes(x = yearest_true, y = 100, xend = yearest_true, yend = population_est, color = scale), alpha = 0.3) +
  
  
  # add arrows for true value and closest point value
  geom_segment(aes(x = yearVal, y = true_value, xend = 0, yend = true_value), size = 0.8, alpha = 0.7, linetype = "solid", color = "gray30", arrow = arrow(length=unit(0.2,"cm"), ends="last", type = "closed")) +
  geom_segment(aes(x = yearVal, y = closest_pt_value, xend = 0, yend = closest_pt_value), size = 0.8, alpha = 0.7, linetype = "solid", color = "gray30", arrow = arrow(length=unit(0.2,"cm"), ends="last", type = "closed")) +
  geom_segment(aes(x = yearVal, y = 100, xend = yearVal, yend = true_value), size = 0.8, alpha = 0.7, linetype = "solid", color = "gray30", arrow = arrow(length=unit(0.2,"cm"), ends="last", type = "closed")) +
  geom_segment(aes(x = yearVal, y = 100, xend = yearVal, yend = closest_pt_value), size = 0.8, alpha = 0.7, linetype = "solid", color = "gray30", arrow = arrow(length=unit(0.2,"cm"), ends="last", type = "closed")) +
  
  # extra
  facet_grid(~dataset) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_color_manual(values = c("steelblue", "orange3"), guide = guide_legend(override.aes = list(alpha = 1))) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_y_continuous(limits = c(100, 55000),
                     breaks = seq(0, 55000, 5000),
                     labels = scales::comma,
                     minor_breaks = c())

log_plot <- qe1_pop_est %>%
  filter(population_est < 55000, year == yearVal, scale == "log2", dataset == datasetID) %>%
ggplot() +
  
  # add points
  geom_point(data = dot_data  %>% filter(dataset == datasetID), aes(x = x, y = y)) +
  
  # add spaghetti segments
  geom_segment(aes(x = yearest_true, y = population_est, xend = 0, yend = population_est, color = scale), alpha = 0.3) +
  geom_segment(aes(x = yearest_true, y = 0, xend = yearest_true, yend = population_est, color = scale), alpha = 0.3) +
  
  
  # add arrows for true value and closest point value
  geom_segment(aes(x = yearVal, y = true_value, xend = 0, yend = true_value), size = 0.8, alpha = 0.7, linetype = "solid", color = "gray30", arrow = arrow(length=unit(0.2,"cm"), ends="last", type = "closed")) +
  geom_segment(aes(x = yearVal, y = closest_pt_value, xend = 0, yend = closest_pt_value), size = 0.8, alpha = 0.7, linetype = "solid", color = "gray30", arrow = arrow(length=unit(0.2,"cm"), ends="last", type = "closed")) +
  geom_segment(aes(x = yearVal, y = 0, xend = yearVal, yend = true_value), size = 0.8, alpha = 0.7, linetype = "solid", color = "gray30", arrow = arrow(length=unit(0.2,"cm"), ends="last", type = "closed")) +
  geom_segment(aes(x = yearVal, y = 0, xend = yearVal, yend = closest_pt_value), size = 0.8, alpha = 0.7, linetype = "solid", color = "gray30", arrow = arrow(length=unit(0.2,"cm"), ends="last", type = "closed")) +
  
  # extra
  facet_grid(~dataset) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_color_manual(values = c("orange3"), guide = guide_legend(override.aes = list(alpha = 1))) +
  scale_fill_manual(values = c("orange3")) +
  scale_y_continuous(trans = "log2",
                     limits = c(100, 55000),
                     breaks = 2^seq(0,10000,1),
                     labels = scales::comma,
                     minor_breaks = c()
                     )

linear_plot + log_plot
}

```


```{r, spaghettiPlotsTogether}

spaghettiPlotsTogether <- function(yearVal, scale){
  
  plot <- qe1_pop_est %>%
    filter(population_est < 55000, year == yearVal) %>%
  ggplot() +
    
    # add points
    geom_point(data = dot_data, aes(x = x, y = y)) +
    
    # add spaghetti segments
    geom_segment(aes(x = yearest_true, y = population_est, xend = 0, yend = population_est, color = scale), alpha = 0.3) +
    geom_segment(aes(x = yearest_true, y = 100, xend = yearest_true, yend = population_est, color = scale), alpha = 0.3) +
    
    
    # add arrows for true value and closest point value
    geom_segment(aes(x = yearVal, y = true_value, xend = 0, yend = true_value), size = 0.8, alpha = 0.7, linetype = "solid", color = "gray30", arrow = arrow(length=unit(0.2,"cm"), ends="last", type = "closed")) +
    geom_segment(aes(x = yearVal, y = closest_pt_value, xend = 0, yend = closest_pt_value), size = 0.8, alpha = 0.7, linetype = "solid", color = "gray30", arrow = arrow(length=unit(0.2,"cm"), ends="last", type = "closed")) +
    geom_segment(aes(x = yearVal, y = 100, xend = yearVal, yend = true_value), size = 0.8, alpha = 0.7, linetype = "solid", color = "gray30", arrow = arrow(length=unit(0.2,"cm"), ends="last", type = "closed")) +
    geom_segment(aes(x = yearVal, y = 100, xend = yearVal, yend = closest_pt_value), size = 0.8, alpha = 0.7, linetype = "solid", color = "gray30", arrow = arrow(length=unit(0.2,"cm"), ends="last", type = "closed")) +
    
    # extra
    facet_grid(~dataset) +
    theme_bw() +
    theme(aspect.ratio = 1) +
    scale_color_manual(values = c("steelblue", "orange3"), guide = guide_legend(override.aes = list(alpha = 1))) +
    scale_fill_manual(values = c("steelblue", "orange3"))
  
  if(scale == "linear"){
    plot <- plot +
      scale_y_continuous(limits = c(100, 55000),
                       breaks = seq(0, 55000, 5000),
                       labels = scales::comma,
                       minor_breaks = c())
  } 
  
  if(scale == "log2"){
    plot <- plot +
    scale_y_continuous(trans = "log2",
                       limits = c(100, 55000),
                       breaks = 2^seq(0,10000,1),
                       labels = scales::comma,
                       minor_breaks = c()
                       )
  }

plot
}

```

```{r, popEstSummaryStats}

popEstSummaryStats <- function(yearVal, datasetID){
 qe1_pop_est %>%
  filter(year == yearVal, dataset == datasetID) %>%
  group_by(dataset, year, scale) %>%
  get_summary_stats(population_est, type = "median_iqr") %>%
  knitr::kable(digits = 2) 
}
```

```{r, popEstDensityPlot}
popEstDensityPlot <- function(yearVal, datasetID, pop_limits, zoom_limits){

  estPlot <- qe1_pop_est %>%
    filter(year == yearVal, dataset == datasetID) %>%
    filter(population_est > pop_limits[1], population_est < pop_limits[2]) %>%
    ggplot(aes(x = population_est, fill = scale)) +
    geom_density(alpha = 0.5, color = NA) +
    geom_vline(aes(xintercept = true_value, linetype = "a")) +
    geom_vline(aes(xintercept = closest_pt_value, linetype = "b")) +
    geom_vline(data = grid_lines_data %>% 
                 filter(dataset == "dataset1", grid_lines > pop_limits[1], grid_lines < pop_limits[2]),
               aes(xintercept = grid_lines, color = scale, linetype = "c")) +
    facet_zoom(xlim = zoom_limits) +
    theme_bw() +
    theme(aspect.ratio = 0.8) +
    scale_color_manual(values = c("steelblue", "orange3")) +
    scale_fill_manual(values = c("steelblue", "orange3")) +
    scale_linetype_manual("", labels = c("True Value", "Closest Point Value", "Grid Line Breaks"), values = c("solid", "dashed", "dotted")) +
    scale_x_continuous("Estimated Population") +
    scale_y_continuous("Density")
  
  estPlot

}
```

```{r, popEstBoxPlot}

popEstBoxPlot <- function(yearVal, datasetID, responseVar, pop_limits, zoom_limits){

  box_plot_orig <- qe1_pop_est %>%
    filter(year == yearVal, dataset == datasetID) %>%
    filter(population_est > pop_limits[1], population_est < pop_limits[2]) %>%
    ggplot(aes_string(x = "scale", y = responseVar, color = "scale", fill = "scale", shape = "scale")) +
    geom_jitter(alpha = 0.05) +
    geom_boxplot(alpha = 0.3, width = 0.2) +
    # geom_violin(alpha = 0.3) +
    facet_zoom(ylim = zoom_limits) +
    theme_bw() +
    theme(aspect.ratio = 1) +
    scale_color_manual(values = c("steelblue", "orange3")) +
    scale_fill_manual(values = c("steelblue", "orange3"))
    
    if(responseVar == "population_est"){
    box_plot <- box_plot_orig +
    geom_hline(aes(yintercept = true_value, linetype = "a")) +
    geom_hline(aes(yintercept = closest_pt_value, linetype = "b")) +
    geom_hline(data = grid_lines_data %>% 
                 filter(dataset == datasetID, grid_lines > pop_limits[1], grid_lines < pop_limits[2]),
               aes(yintercept = grid_lines, color = scale, linetype = "c")) +
    scale_linetype_manual("", labels = c("True Value", "Closest Point Value", "Grid Line Breaks"), values = c("solid", "dashed", "dotted"))
    }
  
  if(responseVar != "population_est"){
    box_plot <- box_plot_orig +
    geom_hline(aes(yintercept = 0), linetype = "dashed")
    }
  
  box_plot
}
```

```{r popEstCommonPlot}
popEstCommonPlot <- function(yearVal, datasetID){
  
  common_plot <- qe1_popest_common_responses %>%
    filter(year == yearVal, dataset == datasetID) %>%
    mutate(population_est = round(population_est, 2)) %>%
    mutate(population_est = factor(population_est, response_order)) %>%
    mutate(population_est = factor(population_est, levels = response_order)) %>%
    ggplot(aes(x = count, xmin = 0, xmax = count, y = population_est, color = scale, shape = scale)) +
    geom_linerange(position = position_dodge(.5)) +
    geom_point(position = position_dodge(0.5)) +
    geom_hline(aes(yintercept = as.factor(round(true_value,2)), linetype = "True")) +
    geom_hline(aes(yintercept = as.factor(round(closest_pt_value,2)), linetype = "Closest Point")) +
    # facet_grid(year ~ dataset) +
    theme_test() +
    theme(aspect.ratio = 0.75) +
    scale_shape_manual("Scale", values = c(1,2)) +
    scale_color_manual("Scale", values = c("steelblue", "orange3")) +
    scale_linetype_manual("Actual Value", values = c("dashed", "solid")) +
    scale_y_discrete("Estimated Population") +
    scale_x_continuous(expand = c(0,1))
  common_plot
}
```

## Year 10

```{r}
spaghettiPlotsTogether(10, "linear")
spaghettiPlotsTogether(10, "log2")
```

### Data set 1
```{r dataset1-10}
spaghettiPlotsSep(10, "dataset1")
popEstSummaryStats(yearVal = 10, datasetID = "dataset1")
popEstDensityPlot(yearVal = 10, datasetID = "dataset1", pop_limits = c(0,5000), zoom_limits = c(0,1000))
popEstCommonPlot(yearVal = 10, datasetID = "dataset1")
popEstBoxPlot(yearVal = 10, datasetID = "dataset1", responseVar = "population_est", pop_limits = c(0, 5000), zoom_limits = c(0, 1000))
popEstBoxPlot(yearVal = 10, datasetID = "dataset1", responseVar = "closest_pt_deviation", pop_limits = c(-1500, 1500), zoom_limits = c(-500, 500))
```

### Data set 2

```{r dataset2-10}
spaghettiPlotsSep(10, "dataset2")
popEstSummaryStats(yearVal = 10, datasetID = "dataset2")
popEstDensityPlot(yearVal = 10, datasetID = "dataset2", pop_limits = c(0,5000), zoom_limits = c(0,1000))
popEstCommonPlot(yearVal = 10, datasetID = "dataset2")
popEstBoxPlot(yearVal = 10, datasetID = "dataset2", responseVar = "population_est", pop_limits = c(0, 5000), zoom_limits = c(0, 1000))
popEstBoxPlot(yearVal = 10, datasetID = "dataset2", responseVar = "closest_pt_deviation", pop_limits = c(-1500, 1500), zoom_limits = c(-500, 500))
```

## Year 20

```{r}
spaghettiPlotsTogether(20, "linear")
spaghettiPlotsTogether(20, "log2")
```

### Dataset 1

```{r dataset1-20}
spaghettiPlotsSep(20, "dataset1")
popEstSummaryStats(yearVal = 20, datasetID = "dataset1")
popEstDensityPlot(yearVal = 20, datasetID = "dataset1", pop_limits = c(0,45000), zoom_limits = c(500,5000))
popEstCommonPlot(yearVal = 20, datasetID = "dataset1")
popEstBoxPlot(yearVal = 20, datasetID = "dataset1", responseVar = "population_est", pop_limits = c(0,20000), zoom_limits = c(500,3000))
popEstBoxPlot(yearVal = 20, datasetID = "dataset1", responseVar = "closest_pt_deviation", pop_limits = c(-30000, 30000), zoom_limits = c(-1000, 1000))
```


### Dataset 2

```{r dataset2-20}
spaghettiPlotsSep(20, "dataset2")
popEstSummaryStats(yearVal = 20, datasetID = "dataset2")
popEstDensityPlot(yearVal = 20, datasetID = "dataset2", pop_limits = c(0,45000), zoom_limits = c(500,5000))
popEstCommonPlot(yearVal = 20, datasetID = "dataset2")
popEstBoxPlot(yearVal = 20, datasetID = "dataset2", responseVar = "population_est", pop_limits = c(0,20000), zoom_limits = c(500,3000))
popEstBoxPlot(yearVal = 20, datasetID = "dataset2", responseVar = "closest_pt_deviation", pop_limits = c(-30000, 30000), zoom_limits = c(-1000, 1000))
```

## Year 40

```{r}
spaghettiPlotsTogether(40, "linear")
spaghettiPlotsTogether(40, "log2")
```

### Dataset 1

```{r dataset1-40}
spaghettiPlotsSep(40, "dataset1")
popEstSummaryStats(yearVal = 40, datasetID = "dataset1")
popEstDensityPlot(yearVal = 40, datasetID = "dataset1", pop_limits = c(10000,45000), zoom_limits = c(15000, 18000))
popEstCommonPlot(yearVal = 40, datasetID = "dataset1")
popEstBoxPlot(yearVal = 40, datasetID = "dataset1", responseVar = "population_est", pop_limits = c(10000,45000), zoom_limits = c(15000,18000))
popEstBoxPlot(yearVal = 40, datasetID = "dataset1", responseVar = "closest_pt_deviation", pop_limits = c(-30000, 30000), zoom_limits = c(-1000, 1000))
```

### Dataset 2

```{r dataset2-40}
spaghettiPlotsSep(40, "dataset2")
popEstSummaryStats(yearVal = 40, datasetID = "dataset2")
popEstDensityPlot(yearVal = 40, datasetID = "dataset2", pop_limits = c(10000,45000), zoom_limits = c(12000, 30000))
popEstCommonPlot(yearVal = 40, datasetID = "dataset2")
popEstBoxPlot(yearVal = 40, datasetID = "dataset2", responseVar = "population_est", pop_limits = c(10000,45000), zoom_limits = c(12000,30000))
popEstBoxPlot(yearVal = 40, datasetID = "dataset2", responseVar = "closest_pt_deviation", pop_limits = c(-30000, 30000), zoom_limits = c(-10000, 1000))
```

# QE2: Estimate a year given a population

## Question
```{r}
estimation_questions %>% filter(q_id == "QE2") %>% knitr::kable(digits = 2)
```

## Closest Points

```{r}
estimation_simulated_data %>% 
  filter(abs(y - 4000) < 1500) %>%
  mutate(x = x - 3000) %>%
  arrange(dataset, y)  %>% 
  knitr::kable(digits = 2)
```

## Data
```{r}
qe2_data <- estimation_model_data %>% 
  filter(q_id == "QE2") %>%
  mutate(response = as.numeric(response),
         closest_pt_value = ifelse(dataset == "dataset1", 24, 27),
         closest_pt_deviation = response - closest_pt_value,
         closest_pt_abs_deviation = abs(closest_pt_deviation),
         .after = abs_deviation) %>%
  filter(response <= 50, response >= 0) %>%
  mutate(true_value = round(true_value, 2))

qe2_data %>%
  select(participant_id, dataset, scale, response, true_value, deviation, abs_deviation, closest_pt_value, closest_pt_deviation, closest_pt_abs_deviation) %>%
  head() %>%
  knitr::kable(digits = 2, caption = "QE2 data set example")
```

## Exploration

```{r, out.width = "80%"}
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-linear-plot-QE2.png"))
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-log-plot-QE2.png"))
```

<div class = 'center'>
```{r}
estimation_plotQE2 <- estimationPlots_closest_pt(qe2_data)
ggplotly(estimation_plotQE2)
```
</div>

## Main Take Aways

### Accuracy

+ About the same on both scales, maybe a slight tendency to overestimate (maybe due to estimating the "visual trend" estimate on the log scale as indicated by data set 1?).
+ Not sure there is enough evidence to claim participants were more accurate on the linear scale, but would like to do more studies focusing on participants ability to read between the y-axis tick marks on the logarithmic scale. They could also be anchoring to the tick mark of 4096.

```{r}
qe2_data %>%
  group_by(dataset, scale) %>%
  get_summary_stats(response, type = "median_iqr") %>%
  knitr::kable(digits = 2)

qe2_density_plot <- qe2_data %>%
  ggplot(aes(x = response, fill = scale)) +
  geom_density(alpha = 0.5, color = NA) +
  geom_vline(aes(xintercept = true_value, linetype = "True")) +
  geom_vline(aes(xintercept = closest_pt_value, linetype = "Closest Point")) +
  facet_grid(~ dataset) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dashed", "dotted")) +
  scale_x_continuous("Estimated Year", limits = c(0, 50)) +
  scale_y_continuous("Density")
qe2_density_plot

qe2_data %>%
  ggplot(aes(x = scale, y = closest_pt_deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_wrap(~dataset) +
  # facet_zoom(ylim = c(-5,5)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_y_continuous(limits = c(-5,5)) +
  ggtitle("Closest Point Deviation (by dataset)")

qe2_data %>%
  ggplot(aes(x = scale, y = closest_pt_deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_zoom(ylim = c(-5,5)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  ggtitle("Closest Point Deviation")

qe2_data %>%
  ggplot(aes(x = scale, y = closest_pt_abs_deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_zoom(ylim = c(-5,5)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  ggtitle("Closest Point Absolute Deviation")
```

### Participants are basing estimates on the simulated data points and not on a visual trendline

+ but... based on the density plots above, on the log scale, participants might have a tendency to be fitting a visual trend first and then estimating as indicated by the overestimation on the log scale for data set 1.

```{r}
qe2_common_responses <- qe2_data %>%
  mutate(true_value = round(true_value, 2)) %>%
  group_by(scale, true_value, closest_pt_value, dataset, response) %>%
  summarize(count = n()) %>%
  filter(count > 3) %>%
  arrange(response)

qe2_common_plotv1 <- qe2_common_responses %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(0.5), alpha = 0.7) +
  geom_point(position = position_dodge(0.5)) +
  geom_hline(aes(yintercept = true_value, linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = closest_pt_value, linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_continuous("Estimated Population")

# qe2_common_plotv1

actual_values_data <- qe2_common_responses %>%
  # filter(scale == "linear", "log") %>%
  select(scale, dataset, true_value, closest_pt_value) %>%
  unique() %>%
  pivot_wider(id_cols = c("scale", "true_value"),
              names_from = "dataset",
              values_from = "closest_pt_value") %>%
  pivot_longer(cols = c("true_value", "dataset2", "dataset1"),
              names_to = "dataset",
              values_to = "response") %>%
  mutate(dataset = ifelse(dataset == "true_value" & scale == "linear", "dataset1",
                          ifelse(dataset == "true_value" & scale == "log2", "dataset2", dataset))) %>%
  mutate(scale = "linear", 
         true_value = NA,
         closest_pt_value = NA,
         count = NA) %>%
  unique() %>%
  # mutate(response = round(response, 2)) %>%
  select(scale, dataset, true_value, closest_pt_value, response, count)

qe2_common_responses <- qe2_common_responses %>%
  rbind(actual_values_data)
response_order <- c(unique(round(qe2_common_responses$response, 2))) %>% sort()

qe2_common_plotv2 <- qe2_common_responses %>%
  mutate(response = round(response, 2)) %>%
  mutate(response = factor(response, levels = response_order)) %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(.5)) +
  geom_point(position = position_dodge(0.5)) +
  geom_hline(aes(yintercept = as.factor(round(true_value,2)), linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = as.factor(round(closest_pt_value,2)), linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_discrete("Estimated Population") +
  scale_x_continuous(expand = c(0,5))
qe2_common_plotv2
```

# QI1: Estimate an additive increase in population between two years

```{r}
estimation_questions %>% filter(q_id == "QI1") %>% knitr::kable()
```

## Closest Points

```{r}
estimation_simulated_data %>% 
  filter(x %in% c(3020, 3040)) %>%
  arrange(dataset) %>%
  pivot_wider(id_cols = c("dataset"),
              names_from = "x",
              values_from = "y") %>%
  mutate(increase = `3040` - `3020`) %>%
  knitr::kable(digits = 2)
```


## Data

+ Truncate data at 30000.

```{r}
qi1_data <- estimation_model_data %>% 
  filter(q_id == "QI1") %>%
  mutate(response = as.numeric(response)) %>%
  mutate(closest_pt_value = ifelse(dataset == "dataset1", 15517.75, 22897.43),
         closest_pt_deviation = response - closest_pt_value,
         closest_pt_abs_deviation = abs(closest_pt_deviation),
         .after = abs_deviation) %>%
  filter(response < 30000)

qi1_data %>%
  select(participant_id, dataset, scale, response, true_value, deviation, abs_deviation, closest_pt_value, closest_pt_deviation, closest_pt_abs_deviation) %>%
  head() %>%
  knitr::kable(digits = 2, caption = "QI1 data set example")
```

## Exploration

+ Quite a few responses in the 10 - 30 range??

```{r, out.width = "80%"}
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-linear-plot-QI1.png"))
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-log-plot-QI1.png"))
```

<div class = 'center'>
```{r}
estimation_plotQI1 <- estimationPlots_closest_pt(qi1_data)
ggplotly(estimation_plotQI1)
```
</div>

## Main Take Aways

### Accuracy

+ Tendency to underestimate the difference (for closest point) and tendency to overestimate the difference (for true value). 

```{r}
qi1_data %>%
  group_by(dataset, scale) %>%
  get_summary_stats(response, type = "median_iqr") %>%
  knitr::kable(digits = 2)

qi1_density_plot <- qi1_data %>%
  filter(response >= 1000) %>%
  ggplot(aes(x = response, fill = scale)) +
  geom_density(alpha = 0.5, color = NA) +
  geom_vline(aes(xintercept = true_value, linetype = "True")) +
  geom_vline(aes(xintercept = closest_pt_value, linetype = "Closest Point")) +
  facet_grid(~ dataset) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_x_continuous("Estimated Difference in Population") +
  scale_y_continuous("Density")
qi1_density_plot

qi1_data %>%
  group_by(dataset, scale) %>%
  get_summary_stats(closest_pt_deviation, type = "median_iqr") %>%
  knitr::kable(digits = 2)

qi1_data %>%
  filter(response >= 1000) %>%
  ggplot(aes(x = scale, y = closest_pt_deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  geom_hline(aes(yintercept = 0), color = "gray30") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_wrap(~dataset) +
  # facet_zoom(ylim = c(-5,5)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_y_continuous("Estimated Deviation") +
  ggtitle("Closest Point Deviation (by dataset)")

qi1_data %>%
  filter(response >= 1000) %>%
  ggplot(aes(x = scale, y = deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  geom_hline(aes(yintercept = 0), color = "gray30") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_wrap(~dataset) +
  # facet_zoom(ylim = c(-5,5)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_y_continuous("Estimated Deviation") +
  ggtitle("True Deviation (by dataset)")
```

### Anchoring & Reading Points

+ For example, 16384 - 1024 = 15360, but that 15000 is still strong.
+ Data set 2 has higher estimates (aka reading the points).

```{r}
qi1_common_responses <- qi1_data %>%
  mutate(true_value = round(true_value, 2)) %>%
  group_by(scale, true_value, closest_pt_value, dataset, response) %>%
  summarize(count = n()) %>%
  filter(count > 3) %>%
  arrange(response)

qi1_common_plotv1 <- qi1_common_responses %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(0.5), alpha = 0.7) +
  geom_point(position = position_dodge(0.5)) +
  geom_hline(aes(yintercept = true_value, linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = closest_pt_value, linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_continuous("Estimated Population")

# qi1_common_plotv1

actual_values_data <- qi1_common_responses %>%
  # filter(scale == "linear", "log") %>%
  select(scale, dataset, true_value, closest_pt_value) %>%
  unique() %>%
  pivot_wider(id_cols = c("scale", "true_value"),
              names_from = "dataset",
              values_from = "closest_pt_value") %>%
  pivot_longer(cols = c("true_value", "dataset2", "dataset1"),
              names_to = "dataset",
              values_to = "response") %>%
  mutate(dataset = ifelse(dataset == "true_value" & scale == "linear", "dataset1",
                          ifelse(dataset == "true_value" & scale == "log2", "dataset2", dataset))) %>%
  mutate(scale = "linear", 
         true_value = NA,
         closest_pt_value = NA,
         count = NA) %>%
  unique() %>%
  # mutate(response = round(response, 2)) %>%
  select(scale, dataset, true_value, closest_pt_value, response, count)

qi1_common_responses <- qi1_common_responses %>%
  rbind(actual_values_data)
response_order <- c(unique(round(qi1_common_responses$response, 2))) %>% sort()

qi1_common_plotv2 <- qi1_common_responses %>%
  mutate(response = round(response, 2)) %>%
  mutate(response = factor(response, levels = response_order)) %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(.5)) +
  geom_point(position = position_dodge(0.5)) +
  geom_hline(aes(yintercept = as.factor(round(true_value,2)), linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = as.factor(round(closest_pt_value,2)), linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_discrete("Estimated Population") +
  scale_x_continuous(expand = c(0,0.5))
qi1_common_plotv2
```

# QI2: Estimate a multiplicative change in population between two years (i.e. how many times larger)

```{r}
estimation_questions %>% filter(q_id == "QI2") %>% knitr::kable()
```

## Closest Points

```{r}
estimation_simulated_data %>% 
  filter(x %in% c(3020, 3040)) %>%
  arrange(dataset) %>%
  pivot_wider(id_cols = c("dataset"),
              names_from = "x",
              values_from = "y") %>%
  mutate(increase = `3040`/`3020`) %>%
  knitr::kable(digits = 2)
```

## Data

+ Truncated at 30000, due to misunderstanding.

```{r}
qi2_data <- estimation_model_data %>% 
  filter(q_id == "QI2") %>%
  mutate(response = as.numeric(response)) %>%
  mutate(closest_pt_value = ifelse(dataset == "dataset1", 11.15, 18.76),
         closest_pt_deviation = response - closest_pt_value,
         closest_pt_abs_deviation = abs(closest_pt_deviation),
         .after = abs_deviation) %>%
  filter(response < 30000)

qi2_data %>%
  select(participant_id, dataset, scale, response, true_value, deviation, abs_deviation, closest_pt_value, closest_pt_deviation, closest_pt_abs_deviation) %>%
  head() %>%
  knitr::kable(digits = 2, caption = "QI2 data set example")
```


## Exploration

```{r, out.width = "80%"}
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-linear-plot-QI2.png"))
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-log-plot-QI2.png"))
```

<div class = 'center'>
```{r}
estimation_plotQI2 <- estimationPlots_closest_pt(qi2_data)
ggplotly(estimation_plotQI2)
```
</div>

## Main Take Aways

### Basic lack of understanding

+ Describe logic from calculation and scratchpad.
+ 15000 was still a common response.

```{r}
estimation_plotQI2
```

### Accuracy

+ Larger variability on linear scale.

```{r}
qi2_data %>%
  group_by(dataset, scale) %>%
  get_summary_stats(response, type = "median_iqr") %>%
  knitr::kable(digits = 2)

qi2_density_plot <- qi2_data %>%
  filter(response < 20) %>%
  ggplot(aes(x = response, fill = scale)) +
  geom_density(alpha = 0.5, color = NA) +
  geom_vline(aes(xintercept = true_value, linetype = "True")) +
  geom_vline(aes(xintercept = closest_pt_value, linetype = "Closest Point")) +
  facet_grid(~ dataset) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_x_continuous("Estimated Difference in Population") +
  scale_y_continuous("Density")
qi2_density_plot

qi2_data %>%
  filter(response < 20) %>%
  ggplot(aes(x = scale, y = closest_pt_deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  geom_hline(aes(yintercept = 0), color = "gray30") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_wrap(~dataset) +
  # facet_zoom(ylim = c(-5,5)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_y_continuous("Estimated Deviation") +
  ggtitle("Closest Point Deviation (by dataset)")

qi2_data %>%
  filter(response < 20) %>%
  ggplot(aes(x = scale, y = deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  geom_hline(aes(yintercept = 0), color = "gray30") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_wrap(~dataset) +
  # facet_zoom(ylim = c(-5,5)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_y_continuous("Estimated Deviation") +
  ggtitle("True Deviation (by dataset)")
```

### Common points

+ Not as strong of an anchoring sense here.
+ Appears to be reading the points.

```{r}
qi2_common_responses <- qi2_data %>%
  mutate(true_value = round(true_value, 2)) %>%
  group_by(scale, true_value, closest_pt_value, dataset, response) %>%
  summarize(count = n()) %>%
  filter(count > 3) %>%
  arrange(response)

qi2_common_plotv1 <- qi2_common_responses %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(0.5), alpha = 0.7) +
  geom_point(position = position_dodge(0.5)) +
  geom_hline(aes(yintercept = true_value, linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = closest_pt_value, linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_continuous("Estimated Population")

# qi2_common_plotv1

actual_values_data <- qi2_common_responses %>%
  # filter(scale == "linear", "log") %>%
  select(scale, dataset, true_value, closest_pt_value) %>%
  unique() %>%
  pivot_wider(id_cols = c("scale", "true_value"),
              names_from = "dataset",
              values_from = "closest_pt_value") %>%
  pivot_longer(cols = c("true_value", "dataset2", "dataset1"),
              names_to = "dataset",
              values_to = "response") %>%
  mutate(dataset = ifelse(dataset == "true_value" & scale == "linear", "dataset1",
                          ifelse(dataset == "true_value" & scale == "log2", "dataset2", dataset))) %>%
  mutate(scale = "linear", 
         true_value = NA,
         closest_pt_value = NA,
         count = NA) %>%
  unique() %>%
  # mutate(response = round(response, 2)) %>%
  select(scale, dataset, true_value, closest_pt_value, response, count)

qi2_common_responses <- qi2_common_responses %>%
  rbind(actual_values_data)
response_order <- c(unique(round(qi2_common_responses$response, 2))) %>% sort()

qi2_common_plotv2 <- qi2_common_responses %>%
  mutate(response = round(response, 2)) %>%
  mutate(response = factor(response, levels = response_order)) %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(.5)) +
  geom_point(position = position_dodge(0.5)) +
  geom_hline(aes(yintercept = as.factor(round(true_value,2)), linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = as.factor(round(closest_pt_value,2)), linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_discrete("Estimated Population") +
  scale_x_continuous(expand = c(0,0.5))
qi2_common_plotv2
```

# QI3: Estimate the number of years necessary to double the population

```{r}
estimation_questions %>% filter(q_id == "QI3") %>% knitr::kable()
```

## Closest Points

From QE1, the estimated population at 10 is:

```{r}
doubled_data <- estimation_simulated_data %>% 
  filter(x == 3010) %>%
  mutate(doubled = y*2)

doubled_data %>%
  knitr::kable(digits = 2)
```

```{r}
estimation_simulated_data %>% 
  left_join(doubled_data %>% select(-c(x, y0, y)), by = c("dataset")) %>%
  mutate(pop_diff = abs(y - doubled),
         year_diff = x - 3010) %>%
  filter(pop_diff < 200) %>%
  arrange(dataset, pop_diff) %>%
  knitr::kable(digits = 2)
```

## Data
```{r}
qi3_data <- estimation_model_data %>% 
  filter(q_id == "QI3") %>%
  mutate(response = as.numeric(response)) %>%
  mutate(closest_pt_value = ifelse(dataset == "dataset1", 4, 6),
         closest_pt_deviation = response - closest_pt_value,
         closest_pt_abs_deviation = abs(closest_pt_deviation),
         .after = abs_deviation) %>%
  filter(response < 50)

qi3_data %>%
  select(participant_id, dataset, scale, response, true_value, deviation, abs_deviation, closest_pt_value, closest_pt_deviation, closest_pt_abs_deviation) %>%
  head() %>%
  knitr::kable(digits = 2, caption = "QI3 data set example")
```

## Exploration

```{r, out.width = "80%"}
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-linear-plot-QI3.png"))
knitr::include_graphics(here("analyses/03-estimation/simulated-plots/simulated-log-plot-QI3.png"))
```

<div class = 'center'>
```{r}
estimation_plotQI3 <- estimationPlots_closest_pt(qi3_data)
ggplotly(estimation_plotQI3)
```
</div>


## Main Take Aways

### Accuracy

+ Larger variability on linear scale.
+ More accurate on log scale??

```{r}
qi3_data %>%
  group_by(dataset, scale) %>%
  get_summary_stats(response, type = "median_iqr") %>%
  knitr::kable(digits = 2)

qi3_density_plot <- qi3_data %>%
  ggplot(aes(x = response, fill = scale)) +
  geom_density(alpha = 0.5, color = NA) +
  geom_vline(aes(xintercept = true_value, linetype = "True")) +
  geom_vline(aes(xintercept = closest_pt_value, linetype = "Closest Point")) +
  facet_grid(~ dataset) +
  theme_bw() +
  theme(aspect.ratio = 1) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_x_continuous("Estimated Difference in Population") +
  scale_y_continuous("Density")
qi3_density_plot

qi3_data %>%
  ggplot(aes(x = scale, y = closest_pt_deviation, color = scale, fill = scale, shape = scale)) +
  geom_jitter(alpha = 0.05) +
  geom_boxplot(alpha = 0.3, width = 0.2) +
  geom_hline(aes(yintercept = 0), color = "gray30") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  facet_wrap(~dataset) +
  # facet_zoom(ylim = c(-5,5)) +
  scale_color_manual(values = c("steelblue", "orange3")) +
  scale_fill_manual(values = c("steelblue", "orange3")) +
  scale_y_continuous("Estimated Deviation") +
  ggtitle("Closest Point Deviation (by dataset)")
```

### Common points

+ Strong anchoring at 5 and 10.

```{r}
qi3_common_responses <- qi3_data %>%
  mutate(true_value = round(true_value, 2)) %>%
  group_by(scale, true_value, closest_pt_value, dataset, response) %>%
  summarize(count = n()) %>%
  filter(count > 3) %>%
  arrange(response)

qi3_common_plotv1 <- qi3_common_responses %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(0.5), alpha = 0.7) +
  geom_point(position = position_dodge(0.5)) +
  geom_hline(aes(yintercept = true_value, linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = closest_pt_value, linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_continuous("Estimated Population")

# qi3_common_plotv1

actual_values_data <- qi3_common_responses %>%
  # filter(scale == "linear", "log") %>%
  select(scale, dataset, true_value, closest_pt_value) %>%
  unique() %>%
  pivot_wider(id_cols = c("scale", "true_value"),
              names_from = "dataset",
              values_from = "closest_pt_value") %>%
  pivot_longer(cols = c("true_value", "dataset2", "dataset1"),
              names_to = "dataset",
              values_to = "response") %>%
  mutate(dataset = ifelse(dataset == "true_value" & scale == "linear", "dataset1",
                          ifelse(dataset == "true_value" & scale == "log2", "dataset2", dataset))) %>%
  mutate(scale = "linear", 
         true_value = NA,
         closest_pt_value = NA,
         count = NA) %>%
  unique() %>%
  # mutate(response = round(response, 2)) %>%
  select(scale, dataset, true_value, closest_pt_value, response, count)

qi3_common_responses <- qi3_common_responses %>%
  rbind(actual_values_data)
response_order <- c(unique(round(qi3_common_responses$response, 2))) %>% sort()

qi3_common_plotv2 <- qi3_common_responses %>%
  mutate(response = round(response, 2)) %>%
  mutate(response = factor(response, levels = response_order)) %>%
  ggplot(aes(x = count, xmin = 0, xmax = count, y = response, color = scale, shape = scale)) +
  geom_linerange(position = position_dodge(.5)) +
  geom_point(position = position_dodge(0.5)) +
  geom_hline(aes(yintercept = as.factor(round(true_value,2)), linetype = "True"), size = 0.8) +
  geom_hline(aes(yintercept = as.factor(round(closest_pt_value,2)), linetype = "Closest Point"), size = 0.8) +
  facet_grid(~ dataset) +
  theme_test() +
  theme(aspect.ratio = 1) +
  scale_shape_manual("Scale", values = c(1,2)) +
  scale_color_manual("Scale", values = c("steelblue", "orange3")) +
  scale_linetype_manual("Actual Value", values = c("dotted", "dashed")) +
  scale_y_discrete("Estimated Population") +
  scale_x_continuous(expand = c(0,0.5))
qi3_common_plotv2
```
